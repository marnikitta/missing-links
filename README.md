# Missing links predictions

#### Roadmap

- [x] Сгенерировать граф
- [x] Сохранить граф, как список ребер
- [x] Найти второй круг
- [x] Посчитать метрики для второго круга
- [x] Сохранить метрики
- [x] Сжать списки ребер с CSR + delta encoding. Положить индекс в каждый чанк
- [x] Отрефакторить код, чтобы можно было считать линейные комбинации

#### Related papers

- [Map-Reduce based Link Prediction for Large Scale Social Network](https://ksiresearchorg.ipage.com/seke/seke17paper/seke17paper_100.pdf)

#### Graph Generation

Наивная реализация алгоритма BA работает за O(n^2), где n - кол-во вершин в генерируемом графе.

В статье [Roulette-wheel selection via stochastic acceptance](https://scholar.google.fr/scholar?cluster=3862086056988553103) предлагают алгоритм, который работает за O(n ^ 1.5).

#### Missing links metrics

Типичные метрики для поиска недостающих ребер: [Predicting missing links via local information](https://scholar.google.fr/scholar?cluster=12704085315179052707)

#### Serialization format

Граф большой, если хранить в лоб выходит ~ 80 гб (10000000 ребер x 8 байт на ребро). Можно хранить как постинг листы в индексе. 
И delta-encoding добавим, чтобы еще немножко выжать, длины чисел только уменьшатся.

_Каноническое предстваление_ - осталяем только ребра ведущие из вершины с меньшим номером в вершину с большим. 
Списки смежных ребер сортируем. При этом кол-во ребер уменьшится вдвое, а сортированные списки помогут сделать delta-encoding эффективнее.

Функции `GraphCanonizer` и `GraphDecanonizer` переводят между двумя предствлениями.

Функции `GraphEncoder` и `GraphDecoder` сжимают канонический граф и разжимают соответственно.

#### Second Circle on MR

Изначально в каждой вершине лежат смежные с ней. В деканонизированном виде.

Делается в два этапа:

1. Каждая вершина пересылает каждой свои списки смежности, в результате в каждой вершине оказывается её потенциальный второй круг
    - __MAP:__ `from: [to0, to1, to2, to3 ...] -> to0: [to1, to2, to3 ...], to1: [to0, to2, to3 ...]`
    - __REDUCE:__ `to0 [to00, to01, to02, ... , to10, to11, to12, ...]`
2. Для каждой вершины из потенциального второго круга удаляем вершины, которые лежат в первом. Для этого делаем __JOIN__ cо списками смежности

_Оптимизация:_ если нужен не весь второй круг, а только `N` вершин, то потенциальный второй круг для вершины `v` можно ограничить `deg(v) + N` вершинами как на __MAP__ стадии, так и на __REDUCE__. 
При этом мапу `v -> deg(v)` можно непосредственно доставлять на каждого воркера.

#### Adamic/Adar

__TBD__

